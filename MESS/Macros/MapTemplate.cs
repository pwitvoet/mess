using MESS.Mapping;
using MESS.Spatial;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MESS.Macros
{
    public enum TemplateAreaAnchor
    {
        Bottom = 0,
        Center = 1,
        Top = 2,
        OriginBrush = 3,
    }


    /// <summary>
    /// A map template holds entities and brushes that can be inserted by <see cref="MacroEntity.Insert"/>, <see cref="MacroEntity.Cover"/> and <see cref="MacroEntity.Fill"/> entities.
    /// Templates may contain sub-templates (<see cref="MacroEntity.Template"/>) and conditional content (<see cref="MacroEntity.RemoveIf"/>).
    /// </summary>
    public class MapTemplate
    {
        // TODO: Expand paths (from .rmf files) into entities, so we don't need to special-case them later on!
        public static MapTemplate Load(string path)
        {
            path = NormalizePath(path);
            var map = MapFile.Load(path);

            // TODO: Expand paths (the Hammer feature that makes creating path_tracks/path_corners/etc. paths 'easy'),
            //       so we don't have to special-case them later on anymore! (without this, entities generated by paths will not be included in templates!)

            var subTemplates = ExtractSubTemplates(map);
            var conditionalContent = ExtractConditionalContent(map);
            return new MapTemplate(map, path, false, "1", subTemplates, conditionalContent);
        }


        /// <summary>
        /// For map files, this is their absolute path.
        /// For sub-templates (<see cref="MacroEntity.Template"/>), this is their name property (which may contain expressions).
        /// </summary>
        public string Name { get; }
        public Map Map { get; }
        public bool IsSubTemplate { get; }
        public string SelectionWeightExpression { get; }

        public IReadOnlyCollection<MapTemplate> SubTemplates { get; }
        public IReadOnlyCollection<RemovableContent> ConditionalContents { get; }


        public MapTemplate(Map map, string name, bool isSubTemplate, string selectionWeightExpression = "1", IEnumerable<MapTemplate> subTemplates = null, IEnumerable<RemovableContent> conditionalContent = null)
        {
            Name = name;
            Map = map;
            SelectionWeightExpression = selectionWeightExpression;
            IsSubTemplate = isSubTemplate;

            SubTemplates = subTemplates?.ToArray() ?? Array.Empty<MapTemplate>();
            ConditionalContents = conditionalContent?.ToArray() ?? Array.Empty<RemovableContent>();
        }


        private static string NormalizePath(string path) => System.IO.Path.GetFullPath(path);


        /// <summary>
        /// Removes any template areas (<see cref="MacroEntity.Template"/>) and their contents from the given map, returning them as a dictionary.
        /// Template area names do not need to be unique, so 
        /// </summary>
        private static IEnumerable<MapTemplate> ExtractSubTemplates(Map map)
        {
            var templateEntities = map.GetEntitiesWithClassName(MacroEntity.Template);
            var objectsMarkedForRemoval = new HashSet<object>(templateEntities);

            // Create a MapTemplate for each macro_template entity. These 'sub-templates' can be only used within the current map:
            var subTemplates = new List<MapTemplate>();
            foreach (var templateEntity in templateEntities)
            {
                var templateArea = templateEntity.BoundingBox;
                var templateName = templateEntity["targetname"] ?? "";
                var selectionWeight = templateEntity["selection_weight"] ?? "";
                var offset = GetTemplateEntityOrigin(templateEntity) * -1;
                var templateMap = new Map();

                // Include all entities that are fully inside this template area (except for other macro_template entities - nesting is not supported):
                foreach (var entity in map.Entities.Where(entity => entity.ClassName != MacroEntity.Template))
                {
                    if (templateArea.Contains(entity))
                    {
                        templateMap.Entities.Add(entity.Copy(offset));
                        objectsMarkedForRemoval.Add(entity);
                    }
                }

                // Include all brushes that are fully inside this template area:
                foreach (var brush in map.WorldGeometry)
                {
                    if (templateArea.Contains(brush))
                    {
                        templateMap.WorldGeometry.Add(brush.Copy(offset));
                        objectsMarkedForRemoval.Add(brush);
                    }
                }


                var conditionalContent = ExtractConditionalContent(templateMap);
                subTemplates.Add(new MapTemplate(templateMap, templateName, true, selectionWeight, conditionalContent: conditionalContent));
            }

            // Now that we've checked all template areas, we can remove the macro_template entities and their contents from the map:
            foreach (var mapObject in objectsMarkedForRemoval)
            {
                switch (mapObject)
                {
                    case Entity entity: map.Entities.Remove(entity); break;
                    case Brush brush: map.WorldGeometry.Remove(brush); break;
                }
                // TODO: They're also still part of groups, vis-groups, etc!
            }

            return subTemplates;
        }

        private static Vector3D GetTemplateEntityOrigin(Entity templateEntity)
        {
            if (!Enum.TryParse<TemplateAreaAnchor>(templateEntity["anchor"], out var anchor))
                anchor = TemplateAreaAnchor.OriginBrush;

            if (anchor == TemplateAreaAnchor.OriginBrush)
            {
                if (templateEntity.GetOrigin() is Vector3D origin)
                    return origin;
            }

            // NOTE: The bottom anchor point is our default fallback for when there's no origin brush.
            switch (anchor)
            {
                default:
                case TemplateAreaAnchor.Bottom: return new Vector3D(templateEntity.BoundingBox.Center.X, templateEntity.BoundingBox.Center.Y, templateEntity.BoundingBox.Min.Z);
                case TemplateAreaAnchor.Center: return templateEntity.BoundingBox.Center;
                case TemplateAreaAnchor.Top: return new Vector3D(templateEntity.BoundingBox.Center.X, templateEntity.BoundingBox.Center.Y, templateEntity.BoundingBox.Max.Z);
            }
        }

        /// <summary>
        /// Removes any remove-if areas (<see cref="MacroEntity.RemoveIf"/>), returning a dictionary that maps expressions (removal conditions) to removable contents.
        /// Remove-if areas can overlap each other, so some contents may be referenced by multiple expressions.
        /// </summary>
        private static IEnumerable<RemovableContent> ExtractConditionalContent(Map map)
        {
            var conditionalContents = new List<RemovableContent>();
            foreach (var removeIfEntity in map.GetEntitiesWithClassName(MacroEntity.RemoveIf))
            {
                var removeIfArea = removeIfEntity.BoundingBox;
                var condition = removeIfEntity["condition"] ?? "";  // TODO: Validate the expression somehow?
                var removableContent = new HashSet<object>();

                // Reference all entities that are fully inside this remove-if area (except for other macro_remove_if entities):
                foreach (var entity in map.Entities.Where(entity => entity.ClassName != MacroEntity.RemoveIf))
                {
                    if (removeIfArea.Contains(entity))
                        removableContent.Add(entity);
                }

                // Reference all bushes that are fully inside this remove-if area:
                foreach (var brush in map.WorldGeometry)
                {
                    if (removeIfArea.Contains(brush))
                        removableContent.Add(brush);
                }


                conditionalContents.Add(new RemovableContent(condition, removableContent));
            }

            // At this point we no longer need the macro_remove_if entities:
            foreach (var removeIfEntity in map.GetEntitiesWithClassName(MacroEntity.RemoveIf).ToArray())
                map.Entities.Remove(removeIfEntity);

            return conditionalContents;
        }
    }
}
