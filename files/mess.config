// MESS configuration file.
// The settings in this file are used as default settings, but most of them can be overridden with command-line arguments.


// This directory is where MESS will look for .ted (Template Entity Definition) files. The rewrite rules in these files will be applied when processing maps.
// This directory can also contain .mtb (MESS Template Bundle) files, which are zip archives that can contain template map and .ted files.
// .mtb files are the preferred way of sharing template entities. If a file exists both inside and outside an .mtb file, then the one outside takes priority,
// in order to aid the development of template entities.
//
// The path can contain MScript expressions, and the following bindings are available:
//   EXE_DIR    The directory where MESS.exe is located.
templates-directory:    {EXE_DIR}\templates


// MESS combines all entity definitions from .ted files into a single .fgd file. Adding this .fgd file to a level editor makes all the template entities available
// in that editor.
//
// The path can contain MScript expressions, and the following bindings are available:
//   EXE_DIR    The directory where MESS.exe is located.
fgd-path:   {EXE_DIR}\mess.fgd


// The maximum recursion depth (recursion is when a template inserts another template). This is a failsafe to prevent accidental infinite recursion.
// Feel free to increase this if you know what you're doing:
max-recursion:      100


// The maximum number of template instances to create. This is a failsafe to prevent accidental infinite loops.
// Feel free to increase this if you know what you're doing:
max-instances:      100000


// The default log level. Available levels are:
//   off        All logging is disabled.
//   minimal    Only a startup and finish message are logged.
//   error      Errors that prevent MESS from continuing will also be logged.
//   warning    Failures that cause MESS to skip certain steps will also be logged.
//   info       Additional information is logged, such as which template maps are being loaded.
//   verbose    Extra information is logged for each instance and entity that is being created.
log-level:          info


// These variables will be available in MScript expressions in the map properties and top-level entities of the input map.
// This can be useful for things like setting an author name, or for setting wad paths when compiling .rmf/.jmf files directly.
// You can add multiple variable assignments here (on separate lines):
variables:
    var1 = 'raw text value'
    var2 = 4 + 5


// Global variables are available in MScript expression, via the getglobal, setglobal and useglobal functions.
// Unlike variables, which are only available in the map properties and in top-level entities, globals are also available
// inside templates and template maps.
// This makes it possible to create templates whose behavior can be configured via global variables,
// for example by generating additional entities if a DEBUG global is set to 1.
globals:
    DEBUG = none
    
    // Globals for MTL (MESS Template Library) entity configuration:
    MTL_MULTIMANAGER_MAX_TARGETS = 16
    MTL_IGNORE_TARGET_PREDICATE = name => name.match('^(?:_tb_)')


// 'Lifted' properties are always evaluated first, and are then made available to MScript expressions in the other properties of the same entity.
// One use-case for this is with TrenchBroom linked groups, where entities that are part of a linked group are tagged with a special '_tb_group' attribute.
// By 'lifting' this attribute and referencing it in other attributes, each linked group instance can produce entities with different names and other values.
lifted-properties:
    _tb_group


// Most Half-Life entities with positive pitch will face downwards. However, some entities (anything that displays a model, and a few others) will face upwards instead.
// Instead of hard-coding a list of entities, MESS lets you write a predicate (which can contain MScript expressions) that will be evaluated for every non-macro entity in a map.
// If the predicate produces a 'true' value (anything except for an empty string or 0) then MESS will use inverted-pitch logic for that entity.
// The entity's classname is the most important attribute to check, but all of the entity's attributes can be used within expressions here:
inverted-pitch-predicate:       {classname.match('^(?:ammo_|item_|monster_|weapon_|xen_|cycler_|env_sprite)')}
